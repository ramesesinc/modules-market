import com.rameses.annotations.*;
import java.text.*;
import com.rameses.functions.*;
import com.rameses.util.*;
import market.facts.*;
import com.rameses.rules.common.*;

import treasury.utils.*;
import treasury.facts.*;


class MarketBillingService {
	
	@Service("BillingRuleService")
	def billingRuleSvc;

	@Service("DateService")
	def dateSvc;

	@DataContext("market_account_rate")
	def acctRate;

	@DataContext("market_account")
	def acctEm;

	def buildRates(def o, def fromdate, def todate, def df ) {
		def list = acctRate.find( [acctid: o.acctid ] ).where('effectivedate >= :ndate', [ndate: fromdate]).orderBy("effectivedate DESC").list();
		def cal = Calendar.instance;
		def mlist = [];
		list.each {
			def ed = df.parse( df.format( it.effectivedate ));
			mlist.add(0, new MarketRentalRate( fromdate: ed, todate: todate, rate: it.rate ));
			cal.setTime( ed );
			cal.add( Calendar.DATE, -1 );
			todate = cal.getTime();
		}
		return mlist;
	}

	@ProxyMethod
	public def getBilling( def o ) {

		def df = new java.text.SimpleDateFormat("yyyy-MM-dd");
		def m = acctEm.find( [objid: o.acctid ] ).first();

		if(!o.billdate) o.billdate = dateSvc.getServerDate();
		if(!o.todate ) o.todate = o.billdate;

		def billdate = df.parse( df.format( o.billdate ));
		def fromdate = df.parse( df.format( o.nextbilldate ));
		def todate = df.parse( df.format( o.todate ));

		def _rates = buildRates(o, fromdate, todate, df );

		def facts = [];
		facts << new MarketBilling(fromdate: fromdate, todate: todate );
		facts << new BillDate( billdate );
		facts.addAll( _rates ); 



		//billitems(year,total,amount,surcharge,interest,discount,item.title), fromdate, todate, duedate, 

	}

}