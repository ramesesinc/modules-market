import com.rameses.annotations.*;

import treasury.facts.*;
import com.rameses.rules.common.*;
import treasury.utils.*;


class MarketUtilityService {
	
	@Service("AssessmentRuleService")
	def assmtSvc;

	@DataContext("market_electricity")
	def elecEm;

	@ProxyMethod 
	public def calculate( params ) {

		def fb = new FactBuilder(); 
		if ( params.usage == null ) params.usage = 0;

		fb.facts << new UtilityRate( type: params.txntype, usage: params.usage ); 
		if ( params.year ) {
			fb.facts << new MonthEntry( year:params.year, month: params.month );
		}

		def m = [:];
		def resultHandler = [
			getFactKeyValue : { v-> 
				if(v instanceof VarDate ) {
					m.nextreadingdate = v.date;
				}
				else if( v instanceof UtilityRate ) {
					m.amount = v.rate;
				}
			}	
		] as ResultHandler;

		assmtSvc.execute( "marketutility", [:], fb, resultHandler );
		if( params.usage && (!m.amount || m.amount <=0 ))
			throw new Exception("Utility rate not computed. Please check the rules");		

		return m;
	} 	

	@ProxyMethod
	public void create( def o ) {
		o.previd = o.prev?.objid;
		def z = elecEm.create( o );
		if(o.prev?.objid) {
			//re update nextid
			elecEm.find( [objid: o.prev.objid] ).update( [nextid: z.objid ] );
		}

		//this is just to ensure that we do not have another null entry
		def c = elecEm.find( [acctid: z.acctid] ).where( "nextid IS NULL").select("c:{COUNT(*)}").val();
		if( c != 1) {
			throw new Exception("There should only be one active current entry. There is a possibility of 2 null nextid entries. Please have this checked by the developer");
		}
	}

	

}